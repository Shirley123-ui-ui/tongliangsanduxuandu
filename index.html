<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>安培环路定理3D可视化 - 移动端优化版</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/utils/BufferGeometryUtils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: none;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }
        
        header {
            padding: 12px 15px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #4fc3f7;
        }
        
        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.4;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }
        
        #visualization-container {
            flex: 1;
            position: relative;
        }
        
        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #controls-panel {
            flex: 0 0 auto;
            background-color: rgba(0, 20, 30, 0.9);
            padding: 15px;
            overflow-y: auto;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 50vh;
            min-height: 300px;
        }
        
        .section-title {
            font-size: 1.3rem;
            margin-bottom: 12px;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 5px;
        }
        
        .model-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .model-btn {
            padding: 10px 12px;
            background-color: rgba(0, 40, 60, 0.7);
            border: 1px solid rgba(79, 195, 247, 0.3);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .model-btn:hover {
            background-color: rgba(0, 60, 90, 0.8);
            transform: translateY(-1px);
        }
        
        .model-btn.active {
            background-color: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.5);
        }
        
        .calculation-box {
            background-color: rgba(0, 30, 50, 0.8);
            border: 2px solid #4fc3f7;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 0 12px rgba(79, 195, 247, 0.3);
        }
        
        .calc-title {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #4fc3f7;
            text-align: center;
        }
        
        .calc-content {
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .calc-value {
            color: #ffcc00;
            font-weight: bold;
            font-size: 1rem;
        }
        
        .calc-formula {
            font-family: 'Cambria', 'Times New Roman', serif;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 6px;
            border-radius: 5px;
            margin: 6px 0;
            text-align: center;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .slider-container {
            margin-bottom: 16px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .slider-label span {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        
        .slider-value {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .slider {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: 2px solid white;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .checkbox-container input {
            margin-right: 10px;
            width: 16px;
            height: 16px;
        }
        
        .info-box {
            background-color: rgba(0, 30, 50, 0.6);
            border-left: 4px solid #4fc3f7;
            padding: 12px;
            margin-top: 20px;
            border-radius: 0 6px 6px 0;
        }
        
        .info-title {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #4fc3f7;
        }
        
        .info-content {
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .legend {
            display: flex;
            align-items: center;
            margin-top: 12px;
            font-size: 0.85rem;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .instructions {
            margin-top: 16px;
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.4;
        }
        
        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            z-index: 10;
        }
        
        .view-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        .view-btn {
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #4fc3f7;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            min-width: 80px;
        }
        
        .view-btn:hover {
            background-color: rgba(79, 195, 247, 0.3);
        }
        
        /* 移动端特殊样式 */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            #controls-panel {
                max-height: 40vh;
                min-height: 250px;
            }
            
            .view-btn {
                min-width: 70px;
                padding: 5px 8px;
                font-size: 0.75rem;
            }
            
            .model-btn {
                padding: 9px 10px;
                font-size: 0.9rem;
            }
            
            .section-title {
                font-size: 1.2rem;
            }
            
            .calc-content {
                font-size: 0.85rem;
            }
            
            .calc-formula {
                font-size: 0.85rem;
            }
            
            .info-content {
                font-size: 0.8rem;
            }
            
            .instructions {
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            header {
                padding: 10px 12px;
            }
            
            #controls-panel {
                padding: 12px;
                min-height: 200px;
            }
            
            .view-btn {
                min-width: 65px;
                padding: 4px 6px;
                font-size: 0.7rem;
            }
            
            .model-btn {
                padding: 8px 9px;
                font-size: 0.85rem;
            }
            
            .section-title {
                font-size: 1.1rem;
            }
            
            .slider-container {
                margin-bottom: 14px;
            }
            
            .calc-content {
                font-size: 0.8rem;
            }
            
            .calc-formula {
                font-size: 0.8rem;
                padding: 5px;
            }
            
            .info-content {
                font-size: 0.75rem;
            }
            
            .instructions {
                font-size: 0.75rem;
            }
        }
        
        /* 解决移动浏览器地址栏缩放问题 */
        @media screen and (max-height: 500px) {
            #controls-panel {
                max-height: 30vh;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <h1>安培环路定理3D可视化</h1>
            <p class="subtitle">∮<sub>C</sub> <b>B</b> · d<b>l</b> = μ₀Iₑₙc</p>
        </header>
        
        <div class="main-content">
            <div id="visualization-container">
                <canvas id="three-canvas"></canvas>
                <div class="coordinates" id="coordinates">x: 0, y: 0, z: 0</div>
                <div class="view-controls">
                    <button class="view-btn" id="top-view">俯视</button>
                    <button class="view-btn" id="side-view">侧视</button>
                    <button class="view-btn" id="reset-view">重置</button>
                </div>
            </div>
            
            <div id="controls-panel">
                <h2 class="section-title">模型选择</h2>
                <div class="model-selector">
                    <button class="model-btn active" data-model="straight-wire">无限长直导线</button>
                    <button class="model-btn" data-model="solenoid">无限长螺线管</button>
                    <button class="model-btn" data-model="toroid">螺绕环</button>
                </div>
                
                <div class="calculation-box">
                    <div class="calc-title">安培环路定理计算结果</div>
                    <div class="calc-content">
                        <div id="current-model-name">无限长直导线</div>
                        <div class="calc-formula" id="field-formula">B = (μ₀I)/(2πr)</div>
                        <div id="field-calculation">磁感应强度 B = <span class="calc-value" id="field-value">0.00 T</span></div>
                        <div id="field-direction">磁场方向：<span class="calc-value" id="direction-value">逆时针(俯视)</span></div>
                    </div>
                </div>
                
                <h2 class="section-title">物理参数</h2>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>电流强度 (I)</span>
                        <span class="slider-value" id="current-value">5.0 A</span>
                    </div>
                    <input type="range" min="-10" max="10" step="0.1" value="5" class="slider" id="current-strength">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>环路半径/尺寸</span>
                        <span class="slider-value" id="loop-size-value">1.5 m</span>
                    </div>
                    <input type="range" min="0.5" max="3" step="0.1" value="1.5" class="slider" id="loop-size">
                </div>
                
                <h2 class="section-title">显示控制</h2>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-field-lines" checked>
                    <label for="show-field-lines">显示磁场线</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="show-amperian-loop" checked>
                    <label for="show-amperian-loop">显示安培环路</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="show-vectors" checked>
                    <label for="show-vectors">显示磁场方向</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="show-current" checked>
                    <label for="show-current">显示电流方向</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="show-field-strength" checked>
                    <label for="show-field-strength">磁场强度颜色</label>
                </div>
                
                <div class="legend">
                    <div class="legend-color" style="background: linear-gradient(to right, #0000ff, #ff0000);"></div>
                    <span>磁场强度：蓝色→红色</span>
                </div>
                
                <div class="legend">
                    <div class="legend-color" style="background-color: #ffff00;"></div>
                    <span>安培环路</span>
                </div>
                
                <div class="legend">
                    <div class="legend-color" style="background-color: #00ff00;"></div>
                    <span>电流正向</span>
                </div>
                
                <div class="legend">
                    <div class="legend-color" style="background-color: #ff00ff;"></div>
                    <span>电流负向</span>
                </div>
                
                <div class="info-box">
                    <div class="info-title">安培环路定理说明</div>
                    <div class="info-content">
                        <p>在稳恒磁场中，磁感应强度 <b>B</b> 沿任意闭合路径 <i>C</i> 的线积分等于穿过以该路径为边界的任意曲面的电流代数和的 μ₀ 倍。</p>
                        <p class="calc-formula">∮<sub>C</sub> <b>B</b> · d<b>l</b> = μ₀Iₑₙc</p>
                        <p>电流的正负由右手定则确定：右手握住导线，拇指指向电流方向，四指环绕方向即为磁场方向。</p>
                    </div>
                </div>
                
                <div class="instructions">
                    <p><strong>交互指南：</strong></p>
                    <p>• 双指缩放，单指旋转</p>
                    <p>• 点击模型按钮切换</p>
                    <p>• 调节电流强度</p>
                    <p>• 使用右上角按钮切换视图</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let currentModel = 'straight-wire';
        let currentStrength = 5.0; // 电流强度，单位A，可为正负
        let loopSize = 1.5;
        let showFieldLines = true;
        let showAmperianLoop = true;
        let showVectors = true;
        let showCurrent = true;
        let showFieldStrength = true;
        
        // 物理常数
        const μ0 = 4 * Math.PI * 1e-7; // 真空磁导率
        
        // 磁场线存储
        let fieldLines = [];
        let amperianLoop = null;
        let currentObjects = [];
        let fieldArrows = [];
        let fieldTubes = []; // 用于存储磁场线管
        
        // 初始化Three.js场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // 创建渲染器
            const canvas = document.getElementById('three-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制高DPR设备的像素比
            
            // 添加轨道控制
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            scene.add(directionalLight);
            
            // 添加坐标轴
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // 初始化模型
            createCurrentModel();
            
            // 添加事件监听
            setupEventListeners();
            
            // 开始动画循环
            animate();
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }
        
        // 设置事件监听
        function setupEventListeners() {
            // 模型选择按钮
            document.querySelectorAll('.model-btn').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('.model-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    currentModel = this.getAttribute('data-model');
                    updateCalculationBox();
                    createCurrentModel();
                });
            });
            
            // 电流强度滑块
            document.getElementById('current-strength').addEventListener('input', function() {
                currentStrength = parseFloat(this.value);
                document.getElementById('current-value').textContent = currentStrength.toFixed(1) + " A";
                createCurrentModel(); // 重新创建模型以更新电流方向
                updateFieldVisualization();
                updateCalculationBox();
            });
            
            // 环路尺寸滑块
            document.getElementById('loop-size').addEventListener('input', function() {
                loopSize = parseFloat(this.value);
                document.getElementById('loop-size-value').textContent = loopSize.toFixed(1) + " m";
                createAmperianLoop();
                updateFieldVisualization();
                updateCalculationBox();
            });
            
            // 复选框控制
            document.getElementById('show-field-lines').addEventListener('change', function() {
                showFieldLines = this.checked;
                updateFieldVisualization();
            });
            
            document.getElementById('show-amperian-loop').addEventListener('change', function() {
                showAmperianLoop = this.checked;
                if (amperianLoop) {
                    amperianLoop.visible = showAmperianLoop;
                }
            });
            
            document.getElementById('show-vectors').addEventListener('change', function() {
                showVectors = this.checked;
                updateFieldVisualization();
            });
            
            document.getElementById('show-current').addEventListener('change', function() {
                showCurrent = this.checked;
                currentObjects.forEach(obj => {
                    obj.visible = showCurrent;
                });
            });
            
            document.getElementById('show-field-strength').addEventListener('change', function() {
                showFieldStrength = this.checked;
                updateFieldVisualization();
            });
            
            // 视图控制按钮
            document.getElementById('top-view').addEventListener('click', function() {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
            });
            
            document.getElementById('side-view').addEventListener('click', function() {
                camera.position.set(10, 0, 0);
                camera.lookAt(0, 0, 0);
            });
            
            document.getElementById('reset-view').addEventListener('click', function() {
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
            });
            
            // 鼠标坐标显示（兼容移动端触摸事件）
            const canvas = document.getElementById('three-canvas');
            const coordDisplay = document.getElementById('coordinates');
            
            // PC端鼠标事件
            canvas.addEventListener('mousemove', function(event) {
                updateCoordinates(event.clientX, event.clientY);
            });
            
            // 移动端触摸事件
            canvas.addEventListener('touchmove', function(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    updateCoordinates(event.touches[0].clientX, event.touches[0].clientY);
                }
            }, { passive: false });
            
            function updateCoordinates(clientX, clientY) {
                // 计算归一化设备坐标
                const rect = canvas.getBoundingClientRect();
                const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((clientY - rect.top) / rect.height) * 2 + 1;
                
                // 创建射线投射器
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                
                // 计算与XY平面的交点 (z=0)
                const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeZ, intersectionPoint);
                
                if (intersectionPoint) {
                    coordDisplay.textContent = `x: ${intersectionPoint.x.toFixed(1)}, y: ${intersectionPoint.y.toFixed(1)}, z: ${intersectionPoint.z.toFixed(1)}`;
                }
            }
        }
        
        // 更新计算框
        function updateCalculationBox() {
            const modelNameElement = document.getElementById('current-model-name');
            const formulaElement = document.getElementById('field-formula');
            const fieldValueElement = document.getElementById('field-value');
            const directionElement = document.getElementById('direction-value');
            
            let title, formula, fieldValue, direction;
            
            switch(currentModel) {
                case 'straight-wire':
                    title = '无限长直导线';
                    formula = 'B = (μ₀I)/(2πr)';
                    const r = loopSize * 1.5;
                    const B_straight = Math.abs(μ0 * currentStrength) / (2 * Math.PI * r);
                    fieldValue = currentStrength === 0 ? '0.00 T' : `${B_straight.toExponential(2)} T`;
                    direction = currentStrength === 0 ? '无磁场' : (currentStrength > 0 ? '逆时针(俯视)' : '顺时针(俯视)');
                    break;
                case 'solenoid':
                    title = '无限长螺线管';
                    formula = 'B = μ₀nI (内部), B ≈ 0 (外部)';
                    const n = 1000; // 单位长度匝数
                    const B_solenoid = Math.abs(μ0 * n * currentStrength);
                    fieldValue = currentStrength === 0 ? '0.00 T' : `${B_solenoid.toExponential(2)} T`;
                    direction = currentStrength === 0 ? '无磁场' : (currentStrength > 0 ? '沿轴线方向(右手定则)' : '沿轴线反方向');
                    break;
                case 'toroid':
                    title = '螺绕环';
                    // 螺绕环内外半径
                    const innerRadius = 2.2; // 内半径
                    const outerRadius = 3.8; // 外半径
                    const loopRadius = loopSize * 1.2; // 安培环路半径
                    
                    // 判断安培环路位置
                    let toroidFormula, B_toroid;
                    if (loopRadius < innerRadius) {
                        // 环路在螺绕环内部，不包含任何电流
                        toroidFormula = 'B = 0 (环路内部)';
                        B_toroid = 0;
                        direction = '无磁场';
                    } else if (loopRadius > outerRadius) {
                        // 环路在螺绕环外部，净电流为0
                        toroidFormula = 'B = 0 (环路外部)';
                        B_toroid = 0;
                        direction = '无磁场';
                    } else {
                        // 环路在螺绕环内部，穿过所有N匝线圈
                        toroidFormula = 'B = (μ₀NI)/(2πr)';
                        const N = 100; // 总匝数
                        B_toroid = Math.abs(μ0 * N * currentStrength) / (2 * Math.PI * loopRadius);
                        direction = currentStrength === 0 ? '无磁场' : (currentStrength > 0 ? '沿环向(右手定则)' : '沿环向反方向');
                    }
                    
                    formula = toroidFormula;
                    fieldValue = currentStrength === 0 || B_toroid === 0 ? '0.00 T' : `${B_toroid.toExponential(2)} T`;
                    break;
            }
            
            modelNameElement.textContent = title;
            formulaElement.innerHTML = formula;
            fieldValueElement.textContent = fieldValue;
            directionElement.textContent = direction;
        }
        
        // 创建当前模型
        function createCurrentModel() {
            // 清除之前的模型
            clearPreviousModel();
            
            // 创建电流模型
            switch(currentModel) {
                case 'straight-wire':
                    createStraightWire();
                    break;
                case 'solenoid':
                    createSolenoid();
                    break;
                case 'toroid':
                    createToroid();
                    break;
            }
            
            // 创建安培环路
            createAmperianLoop();
            
            // 创建磁场可视化
            updateFieldVisualization();
            
            // 更新计算框
            updateCalculationBox();
        }
        
        // 清除之前的模型
        function clearPreviousModel() {
            // 清除磁场线
            fieldLines.forEach(line => scene.remove(line));
            fieldLines = [];
            
            // 清除安培环路
            if (amperianLoop) {
                scene.remove(amperianLoop);
                amperianLoop = null;
            }
            
            // 清除电流对象
            currentObjects.forEach(obj => scene.remove(obj));
            currentObjects = [];
            
            // 清除磁场箭头
            fieldArrows.forEach(arrow => scene.remove(arrow));
            fieldArrows = [];
            
            // 清除磁场线管
            fieldTubes.forEach(tube => scene.remove(tube));
            fieldTubes = [];
        }
        
        // 创建无限长直导线模型 - 最终优化
        function createStraightWire() {
            // 创建导线主体（圆柱体）
            const wireLength = 10;
            const wireGeometry = new THREE.CylinderGeometry(0.05, 0.05, wireLength, 16);
            const wireMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xcccccc, 
                shininess: 100,
                emissive: 0x333333,
                emissiveIntensity: 0.2
            });
            const wire = new THREE.Mesh(wireGeometry, wireMaterial);
            scene.add(wire);
            currentObjects.push(wire);
            
            // 如果电流为0，不显示电流方向箭头
            if (currentStrength === 0) {
                return;
            }
            
            // 根据电流方向确定箭头颜色和方向
            const currentDirection = currentStrength > 0 ? 1 : -1;
            const arrowColor = currentStrength > 0 ? 0x00ff00 : 0xff00ff; // 正向绿色，负向紫色
            const arrowDirection = new THREE.Vector3(0, currentDirection, 0);
            
            // 创建更明显的电流方向箭头
            const arrowCount = 10;
            const arrowSpacing = wireLength / arrowCount;
            
            for (let i = 0; i < arrowCount; i++) {
                const yPos = -wireLength/2 + (i + 0.5) * arrowSpacing;
                
                // 创建箭头主体（粗圆柱体）
                const arrowBodyGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.6, 8);
                const arrowBodyMaterial = new THREE.MeshPhongMaterial({ color: arrowColor, emissive: arrowColor, emissiveIntensity: 0.3 });
                const arrowBody = new THREE.Mesh(arrowBodyGeometry, arrowBodyMaterial);
                arrowBody.position.set(0, yPos, 0);
                arrowBody.rotation.x = Math.PI / 2; // 水平放置
                scene.add(arrowBody);
                currentObjects.push(arrowBody);
                
                // 创建箭头头部（大圆锥体）
                const arrowHeadGeometry = new THREE.ConeGeometry(0.12, 0.4, 12);
                const arrowHeadMaterial = new THREE.MeshPhongMaterial({ color: arrowColor, emissive: arrowColor, emissiveIntensity: 0.5 });
                const arrowHead = new THREE.Mesh(arrowHeadGeometry, arrowHeadMaterial);
                
                // 根据电流方向调整箭头方向
                const headYPos = yPos + (currentDirection * 0.5);
                arrowHead.position.set(0, headYPos, 0);
                arrowHead.rotation.x = currentDirection > 0 ? Math.PI : 0;
                
                scene.add(arrowHead);
                currentObjects.push(arrowHead);
                
                // 添加发光效果
                const pointLight = new THREE.PointLight(arrowColor, 0.5, 1);
                pointLight.position.set(0, yPos, 0);
                scene.add(pointLight);
                currentObjects.push(pointLight);
            }
            
            // 添加电流方向文字标签
            createCurrentDirectionLabel(currentDirection);
        }
        
        // 创建电流方向标签
        function createCurrentDirectionLabel(direction) {
            // 创建文字标签的几何体
            const loader = new THREE.FontLoader();
            
            // 如果没有字体加载器，使用简单的几何体表示
            const labelGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.05);
            const labelMaterial = new THREE.MeshPhongMaterial({ 
                color: direction > 0 ? 0x00ff00 : 0xff00ff,
                emissive: direction > 0 ? 0x00ff00 : 0xff00ff,
                emissiveIntensity: 0.5
            });
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(0, 5.5, 0);
            scene.add(label);
            currentObjects.push(label);
            
            // 添加方向箭头
            const dirArrowGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const dirArrowMaterial = new THREE.MeshPhongMaterial({ 
                color: direction > 0 ? 0x00ff00 : 0xff00ff,
                emissive: direction > 0 ? 0x00ff00 : 0xff00ff,
                emissiveIntensity: 0.5
            });
            const dirArrow = new THREE.Mesh(dirArrowGeometry, dirArrowMaterial);
            dirArrow.position.set(0, direction > 0 ? 5.8 : 5.2, 0);
            dirArrow.rotation.x = direction > 0 ? Math.PI : 0;
            scene.add(dirArrow);
            currentObjects.push(dirArrow);
        }
        
        // 创建无限长螺线管模型 - 已修复：确保右手定则正确应用
        function createSolenoid() {
            const radius = 1.5;
            const length = 8;
            const turns = 12;
            const coilColor = 0xcccccc;
            const arrowColor = currentStrength > 0 ? 0x00ff00 : (currentStrength < 0 ? 0xff00ff : 0x888888);
            const currentDirection = Math.sign(currentStrength);
            
            // 创建连续的螺旋线 - 关键修复：确保右手定则正确应用
            // 根据右手定则：右手握住螺线管，四指弯曲方向指向电流方向，则大拇指指向磁场方向
            // 这意味着当电流向上时（从下往上看电流应该是顺时针方向），这样大拇指才能向上
            // 当电流向下时（从下往上看电流应该是逆时针方向），这样大拇指向下
            
            const points = [];
            const numPoints = 200;
            
            // 根据电流方向确定螺旋线的缠绕方向
            // 当电流为正（向上）时，从下往上看电流应该是顺时针方向（角度减少）
            // 当电流为负（向下）时，从下往上看电流应该是逆时针方向（角度增加）
            const spiralDirection = currentStrength >= 0 ? -1 : 1; // 修复：向上时顺时针，向下时逆时针
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const angle = t * turns * Math.PI * 2 * spiralDirection;
                const y = -length/2 + t * length;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            // 创建管道几何体
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(curve, numPoints, 0.05, 8, false);
            const tubeMaterial = new THREE.MeshPhongMaterial({ 
                color: coilColor,
                emissive: coilColor,
                emissiveIntensity: 0.1
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tube);
            currentObjects.push(tube);
            
            // 如果电流为0，不显示电流方向箭头
            if (currentStrength === 0) {
                return;
            }
            
            // 创建电流方向指示箭头（在螺旋线上）
            const arrowCount = 16;
            
            for (let i = 0; i < arrowCount; i++) {
                const t = (i + 0.5) / arrowCount; // 稍微偏移以避免在端点
                const point = curve.getPoint(t);
                const tangent = curve.getTangent(t);
                
                // 创建箭头
                const arrowHeadGeometry = new THREE.ConeGeometry(0.1, 0.4, 12);
                const arrowHeadMaterial = new THREE.MeshPhongMaterial({ 
                    color: arrowColor,
                    emissive: arrowColor,
                    emissiveIntensity: 0.5
                });
                const arrowHead = new THREE.Mesh(arrowHeadGeometry, arrowHeadMaterial);
                
                // 设置箭头位置和方向
                arrowHead.position.copy(point);
                arrowHead.lookAt(point.clone().add(tangent));
                arrowHead.rotateX(Math.PI / 2);
                
                scene.add(arrowHead);
                currentObjects.push(arrowHead);
                
                // 添加发光效果
                const pointLight = new THREE.PointLight(arrowColor, 0.3, 0.5);
                pointLight.position.copy(point);
                scene.add(pointLight);
                currentObjects.push(pointLight);
            }
            
            // 添加电流方向标签
            if (currentStrength !== 0) {
                createCurrentDirectionLabel(currentDirection);
            }
        }
        
        // 创建螺绕环模型 - 最终优化
        function createToroid() {
            const majorRadius = 3;
            const minorRadius = 0.8;
            const turns = 20;
            const coilColor = 0xcccccc;
            const arrowColor = currentStrength > 0 ? 0x00ff00 : (currentStrength < 0 ? 0xff00ff : 0x888888);
            const currentDirection = Math.sign(currentStrength);
            
            // 创建连续的环形螺旋线
            const points = [];
            const numPoints = 300;
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const angle = t * turns * Math.PI * 2;
                
                // 计算主环上的位置
                const majorX = majorRadius * Math.cos(angle / turns);
                const majorZ = majorRadius * Math.sin(angle / turns);
                
                // 计算螺旋线相对于主环的位置
                const minorX = minorRadius * Math.cos(angle);
                const minorY = minorRadius * Math.sin(angle);
                
                // 组合得到最终位置
                const x = majorX + minorX * Math.cos(angle / turns);
                const y = minorY;
                const z = majorZ + minorX * Math.sin(angle / turns);
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            // 创建管道几何体
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(curve, numPoints, 0.05, 8, false);
            const tubeMaterial = new THREE.MeshPhongMaterial({ 
                color: coilColor,
                emissive: coilColor,
                emissiveIntensity: 0.1
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tube);
            currentObjects.push(tube);
            
            // 如果电流为0，不显示电流方向箭头
            if (currentStrength === 0) {
                return;
            }
            
            // 创建电流方向指示箭头
            const arrowCount = 20;
            
            for (let i = 0; i < arrowCount; i++) {
                const t = i / arrowCount;
                const point = curve.getPoint(t);
                const tangent = curve.getTangent(t);
                
                // 创建箭头
                const arrowHeadGeometry = new THREE.ConeGeometry(0.08, 0.3, 12);
                const arrowHeadMaterial = new THREE.MeshPhongMaterial({ 
                    color: arrowColor,
                    emissive: arrowColor,
                    emissiveIntensity: 0.5
                });
                const arrowHead = new THREE.Mesh(arrowHeadGeometry, arrowHeadMaterial);
                
                // 设置箭头位置和方向
                arrowHead.position.copy(point);
                arrowHead.lookAt(point.clone().add(tangent));
                arrowHead.rotateX(Math.PI / 2);
                
                scene.add(arrowHead);
                currentObjects.push(arrowHead);
                
                // 添加发光效果
                const pointLight = new THREE.PointLight(arrowColor, 0.2, 0.5);
                pointLight.position.copy(point);
                scene.add(pointLight);
                currentObjects.push(pointLight);
            }
            
            // 添加电流方向标签
            if (currentStrength !== 0) {
                createCurrentDirectionLabel(currentDirection);
            }
        }
        
        // 创建安培环路 - 已修改：线宽改为15
        function createAmperianLoop() {
            // 移除旧的环路
            if (amperianLoop) {
                scene.remove(amperianLoop);
            }
            
            let loopGeometry, loopMaterial, loop;
            
            switch(currentModel) {
                case 'straight-wire':
                    // 圆形环路
                    const radius = loopSize * 1.5;
                    const circlePoints = [];
                    const circleSegments = 64;
                    
                    for (let i = 0; i <= circleSegments; i++) {
                        const angle = (i / circleSegments) * Math.PI * 2;
                        circlePoints.push(new THREE.Vector3(
                            radius * Math.cos(angle),
                            0,
                            radius * Math.sin(angle)
                        ));
                    }
                    
                    loopGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
                    loopMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffff00, // 更鲜艳的黄色
                        linewidth: 15, // 线宽改为15
                        transparent: true,
                        opacity: 0.9
                    });
                    loop = new THREE.Line(loopGeometry, loopMaterial);
                    break;
                    
                case 'solenoid':
                    // 矩形环路
                    const width = loopSize * 2;
                    const height = loopSize * 3;
                    
                    const rectPoints = [
                        new THREE.Vector3(-width/2, -height/2, 0),
                        new THREE.Vector3(width/2, -height/2, 0),
                        new THREE.Vector3(width/2, height/2, 0),
                        new THREE.Vector3(-width/2, height/2, 0),
                        new THREE.Vector3(-width/2, -height/2, 0)
                    ];
                    
                    loopGeometry = new THREE.BufferGeometry().setFromPoints(rectPoints);
                    loopMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffff00, // 更鲜艳的黄色
                        linewidth: 15, // 线宽改为15
                        transparent: true,
                        opacity: 0.9
                    });
                    loop = new THREE.Line(loopGeometry, loopMaterial);
                    loop.position.x = loopSize;
                    break;
                    
                case 'toroid':
                    // 圆形环路（位于环内）
                    const toroidRadius = loopSize * 1.2;
                    const toroidCirclePoints = [];
                    const toroidCircleSegments = 64;
                    
                    for (let i = 0; i <= toroidCircleSegments; i++) {
                        const angle = (i / toroidCircleSegments) * Math.PI * 2;
                        toroidCirclePoints.push(new THREE.Vector3(
                            toroidRadius * Math.cos(angle),
                            0,
                            toroidRadius * Math.sin(angle)
                        ));
                    }
                    
                    loopGeometry = new THREE.BufferGeometry().setFromPoints(toroidCirclePoints);
                    loopMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffff00, // 更鲜艳的黄色
                        linewidth: 15, // 线宽改为15
                        transparent: true,
                        opacity: 0.9
                    });
                    loop = new THREE.Line(loopGeometry, loopMaterial);
                    break;
            }
            
            scene.add(loop);
            amperianLoop = loop;
            amperianLoop.visible = showAmperianLoop;
        }
        
        // 更新磁场可视化
        function updateFieldVisualization() {
            // 清除之前的磁场可视化
            fieldLines.forEach(line => scene.remove(line));
            fieldLines = [];
            
            fieldArrows.forEach(arrow => scene.remove(arrow));
            fieldArrows = [];
            
            fieldTubes.forEach(tube => scene.remove(tube));
            fieldTubes = [];
            
            if (showFieldLines) {
                createFieldLines();
            }
            
            if (showVectors) {
                createFieldVectors();
            }
        }
        
        // 创建磁场线
        function createFieldLines() {
            // 如果电流为0，不显示磁场线
            if (currentStrength === 0) {
                return;
            }
            
            switch(currentModel) {
                case 'straight-wire':
                    createStraightWireFieldLines();
                    break;
                case 'solenoid':
                    createSolenoidFieldLines();
                    break;
                case 'toroid':
                    createToroidFieldLines();
                    break;
            }
        }
        
        // 创建无限长直导线的磁场线 - 最终优化
        function createStraightWireFieldLines() {
            const currentDirection = currentStrength > 0 ? 1 : -1;
            const fieldDirection = currentDirection >= 0 ? 1 : -1; // 磁场方向与电流方向的关系
            
            // 根据电流强度决定磁场线条数
            const baseLines = 8;
            const additionalLines = Math.floor(Math.abs(currentStrength) / 2);
            const numCircles = Math.min(baseLines + additionalLines, 20);
            const maxRadius = 4;
            
            for (let i = 1; i <= numCircles; i++) {
                const radius = (i / numCircles) * maxRadius;
                
                // 创建圆环点
                const points = [];
                const segments = 64;
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                
                // 计算该半径处的磁场强度
                const fieldStrength = Math.abs(μ0 * currentStrength) / (2 * Math.PI * radius);
                const normalizedStrength = Math.min(fieldStrength * 1e6, 1.0); // 缩放以便可视化
                
                // 根据是否显示磁场强度颜色来选择颜色
                let color;
                if (showFieldStrength) {
                    // 使用颜色渐变：蓝色(弱) -> 红色(强)
                    color = new THREE.Color();
                    color.setRGB(normalizedStrength, 0, 1 - normalizedStrength);
                } else {
                    // 固定颜色，根据磁场方向选择
                    color = fieldDirection >= 0 ? new THREE.Color(0x00aaff) : new THREE.Color(0xffaa00);
                }
                
                // 创建线几何体 - 使用更粗的线
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: color,
                    linewidth: 4, // 加粗磁场线
                    transparent: true,
                    opacity: 0.8
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
                fieldLines.push(line);
                
                // 在磁场线上添加方向箭头
                if (showVectors) {
                    const arrowCount = 8;
                    for (let k = 0; k < arrowCount; k++) {
                        const angle = (k / arrowCount) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        
                        // 磁场方向：切线方向
                        const direction = new THREE.Vector3(-z * fieldDirection, 0, x * fieldDirection).normalize();
                        
                        // 创建箭头
                        const arrow = new THREE.ArrowHelper(
                            direction,
                            new THREE.Vector3(x, 0, z),
                            Math.min(radius * 0.3, 0.8),
                            color.getHex(),
                            0.2,
                            0.1
                        );
                        
                        scene.add(arrow);
                        fieldArrows.push(arrow);
                    }
                }
            }
        }
        
        // 创建螺线管的磁场线 - 已修复：确保右手定则正确应用
        function createSolenoidFieldLines() {
            const currentDirection = currentStrength > 0 ? 1 : -1;
            
            // 螺线管内部磁场线（平行直线）
            // 使用固定数量的磁场线，但通过颜色变化表示强度变化
            const numLines = 9; // 3x3网格
            const lineLength = 6;
            const solenoidRadius = 1.5;
            
            // 计算磁场强度
            const fieldStrength = Math.abs(μ0 * 1000 * currentStrength); // n = 1000
            const normalizedStrength = Math.min(fieldStrength * 1e5, 1.0);
            
            for (let i = 0; i < numLines; i++) {
                // 在螺线管内部均匀分布点
                const row = Math.floor(i / 3) - 1; // -1, 0, 1
                const col = (i % 3) - 1; // -1, 0, 1
                
                // 确保点在螺线管内部
                const x = col * solenoidRadius * 0.5;
                const z = row * solenoidRadius * 0.5;
                
                // 检查点是否在螺线管内部
                const distanceFromAxis = Math.sqrt(x*x + z*z);
                if (distanceFromAxis > solenoidRadius * 0.9) {
                    continue; // 点太靠近边缘，跳过
                }
                
                // 选择颜色
                let color;
                if (showFieldStrength) {
                    color = new THREE.Color();
                    color.setRGB(normalizedStrength, 0, 1 - normalizedStrength);
                } else {
                    color = currentDirection >= 0 ? new THREE.Color(0x00aaff) : new THREE.Color(0xffaa00);
                }
                
                // 创建磁场线管（使用管道几何体）
                const startPoint = new THREE.Vector3(x, -lineLength/2, z);
                const endPoint = new THREE.Vector3(x, lineLength/2, z);
                
                // 创建线点
                const linePoints = [
                    startPoint,
                    endPoint
                ];
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: color,
                    linewidth: 4, // 加粗磁场线
                    transparent: true,
                    opacity: 0.8
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
                fieldLines.push(line);
                
                // 在磁场线上添加方向箭头
                if (showVectors) {
                    // 根据右手定则：当电流沿螺线管向上时，磁场方向向上；反之向下
                    const direction = new THREE.Vector3(0, currentDirection, 0);
                    
                    // 在线段中点添加箭头
                    const midPoint = new THREE.Vector3(x, 0, z);
                    const arrow = new THREE.ArrowHelper(
                        direction,
                        midPoint,
                        Math.min(normalizedStrength * 1.0, 0.8),
                        color.getHex(),
                        0.2,
                        0.1
                    );
                    
                    scene.add(arrow);
                    fieldArrows.push(arrow);
                }
            }
        }
        
        // 创建螺绕环的磁场线 - 最终优化
        function createToroidFieldLines() {
            const currentDirection = currentStrength > 0 ? 1 : -1;
            
            // 根据电流强度决定磁场线条数
            const baseLines = 6;
            const additionalLines = Math.floor(Math.abs(currentStrength) / 2);
            const numCircles = Math.min(baseLines + additionalLines, 15);
            const innerRadius = 2.2; // 螺绕环内半径
            const outerRadius = 3.8; // 螺绕环外半径
            
            for (let i = 0; i < numCircles; i++) {
                const radius = innerRadius + (i / (numCircles-1)) * (outerRadius - innerRadius);
                
                // 创建圆环点
                const points = [];
                const segments = 64;
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                
                // 计算该半径处的磁场强度
                const N = 100; // 总匝数
                const fieldStrength = Math.abs(μ0 * N * currentStrength) / (2 * Math.PI * radius);
                const normalizedStrength = Math.min(fieldStrength * 1e6, 1.0);
                
                // 选择颜色
                let color;
                if (showFieldStrength) {
                    color = new THREE.Color();
                    color.setRGB(normalizedStrength, 0, 1 - normalizedStrength);
                } else {
                    color = currentDirection >= 0 ? new THREE.Color(0x00aaff) : new THREE.Color(0xffaa00);
                }
                
                // 创建线几何体
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: color,
                    linewidth: 4, // 加粗磁场线
                    transparent: true,
                    opacity: 0.8
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
                fieldLines.push(line);
                
                // 在磁场线上添加方向箭头
                if (showVectors) {
                    const arrowCount = 8;
                    for (let k = 0; k < arrowCount; k++) {
                        const angle = (k / arrowCount) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        
                        // 磁场方向：切线方向
                        const direction = new THREE.Vector3(-z * currentDirection, 0, x * currentDirection).normalize();
                        
                        // 创建箭头
                        const arrow = new THREE.ArrowHelper(
                            direction,
                            new THREE.Vector3(x, 0, z),
                            Math.min(radius * 0.15, 0.6),
                            color.getHex(),
                            0.15,
                            0.08
                        );
                        
                        scene.add(arrow);
                        fieldArrows.push(arrow);
                    }
                }
            }
        }
        
        // 创建磁场矢量箭头
        function createFieldVectors() {
            // 对于直导线，磁场方向已经在磁场线中包含了箭头
            // 对于其他模型，如果需要额外的箭头，可以在这里添加
            // 目前磁场方向箭头已经在创建磁场线时添加了
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            const canvas = document.getElementById('three-canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新控制
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 初始化应用
        init();
        updateCalculationBox();
    </script>
</body>
</html>



